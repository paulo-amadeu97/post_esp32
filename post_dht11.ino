#include <WiFi.h>
#include <HTTPClient.h>
#include <DHT.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

//WIFI
const char *ssid = "robotica";
const char *password = "12345678";

//DHT
#define DHTPIN 26
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

//OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire);

//LOGO DE ADS
const unsigned char adsLogo[] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfc, 0x00, 0x00, 0x3f, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xf0, 0x00, 0x00, 0x0f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x78, 0x7f, 0xc0, 0x00, 0x00, 0x03, 0xfe, 0x1e, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x70, 0xff, 0x80, 0x00, 0x00, 0x01, 0xff, 0x0e, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x73, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8e, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x6f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe6, 0x3f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0xff, 0xf8, 0x07, 0xfe, 0x00, 0x00, 0x1f, 0xfe, 0x3f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xec, 0xff, 0xf0, 0x1e, 0x4f, 0x80, 0x00, 0x0f, 0xff, 0x37, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xec, 0xe1, 0xe0, 0x6c, 0x44, 0xc0, 0x00, 0x07, 0x85, 0x77, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xce, 0x43, 0xc0, 0xd8, 0x42, 0x30, 0x00, 0x07, 0xc3, 0x73, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xce, 0x0f, 0xc1, 0x10, 0x43, 0x18, 0x00, 0x03, 0xf0, 0x73, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc6, 0xff, 0x82, 0x30, 0x41, 0x0c, 0x00, 0x01, 0xff, 0x63, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc7, 0xff, 0x86, 0x20, 0x41, 0x84, 0x00, 0x01, 0xff, 0xe3, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0xe7, 0x8f, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xf1, 0xe7, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0xe6, 0x1f, 0x0c, 0x60, 0xc0, 0xc3, 0x00, 0x00, 0xf8, 0x67, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x78, 0x3e, 0x08, 0x40, 0x40, 0x41, 0x00, 0x00, 0x7c, 0x1e, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x18, 0x40, 0x40, 0x41, 0x00, 0x00, 0x7f, 0xde, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x37, 0xfc, 0x10, 0xc0, 0x40, 0x41, 0x80, 0x00, 0x7f, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x37, 0x3c, 0x10, 0xc0, 0x40, 0x41, 0x80, 0x00, 0x3c, 0xec, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x3c, 0x7c, 0x10, 0x80, 0x40, 0x40, 0x80, 0x00, 0x3e, 0x2c, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xb8, 0x7c, 0x1f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x3e, 0x1d, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfb, 0xf0, 0xfc, 0x10, 0xc0, 0x40, 0x44, 0x80, 0x00, 0x3f, 0x0b, 0xdf, 0xff, 0xff, 
	0xff, 0xff, 0xf9, 0xef, 0xf8, 0x10, 0xc0, 0x40, 0x7f, 0x80, 0x00, 0x3f, 0xf7, 0x9f, 0xff, 0xff, 
	0xff, 0xff, 0xf8, 0xef, 0x78, 0x10, 0xc0, 0x40, 0x40, 0x80, 0x00, 0x3e, 0xf7, 0x1f, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0xee, 0x78, 0x10, 0x40, 0x40, 0x80, 0x40, 0x00, 0x1e, 0x76, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x7c, 0x78, 0x18, 0x40, 0x41, 0x80, 0x20, 0x00, 0x1e, 0x36, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x38, 0xf8, 0x08, 0x40, 0x41, 0x00, 0x20, 0x00, 0x1f, 0x14, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x31, 0xf8, 0x0f, 0xff, 0xff, 0x00, 0x20, 0x00, 0x3f, 0x84, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf7, 0xe7, 0xf8, 0x07, 0xff, 0xff, 0x00, 0x20, 0x00, 0x3f, 0xe7, 0xef, 0xff, 0xff, 
	0xff, 0xff, 0xf3, 0xef, 0x7c, 0x06, 0x30, 0x41, 0x00, 0x20, 0x00, 0x3e, 0xf7, 0xcf, 0xff, 0xff, 
	0xff, 0xff, 0xf8, 0xee, 0x7c, 0x03, 0x10, 0x43, 0x80, 0x20, 0x00, 0x3e, 0x7f, 0x1f, 0xff, 0xff, 
	0xff, 0xff, 0xf8, 0x7c, 0x7c, 0x01, 0x98, 0x42, 0x80, 0x40, 0x00, 0x3e, 0x3e, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x3c, 0x7c, 0x00, 0xcc, 0x46, 0x61, 0xe0, 0x00, 0x3e, 0x3c, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x3c, 0xfe, 0x00, 0x34, 0x4d, 0xff, 0x70, 0x00, 0x7f, 0x3c, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x95, 0xde, 0x00, 0x1f, 0x5f, 0x00, 0x38, 0x00, 0x7b, 0xa9, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf7, 0x9e, 0x00, 0x03, 0xf8, 0x00, 0x1c, 0x00, 0x79, 0xef, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf9, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xf8, 0xff, 0x9f, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x7b, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xf8, 0xfe, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x1f, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x03, 0x81, 0xf8, 0xf8, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x0f, 0x37, 0x80, 0x00, 0x00, 0x00, 0x01, 0xc1, 0xec, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc7, 0x77, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xce, 0xe3, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0xe3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x47, 0xc7, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0x62, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x46, 0xf8, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x83, 0xe6, 0x78, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x67, 0xc1, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xe0, 0xee, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x77, 0x07, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf8, 0x1e, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x78, 0x1f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xee, 0x7f, 0x80, 0x00, 0x00, 0x01, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x67, 0xc0, 0x00, 0x00, 0x07, 0xe6, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x1a, 0xe7, 0xf0, 0x00, 0x00, 0x0f, 0xe7, 0x78, 0x0f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x04, 0xe3, 0xfe, 0x00, 0x00, 0x7f, 0xc7, 0x20, 0x3f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xc0, 0x07, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

//PORTA E BUZZER
#define DOOR 25
#define DOOR_CLOSE 33
#define BOTON 19
#define BUZZER_PIN 32

//URL DA API
const char* serverUrl = "http://192.168.43.203:8080/statedata/";

//CONTROLE DE TEMPO E BEEP
unsigned long previousMillis = 0;
bool isBeeping = false;
unsigned long doorOpenTime = 0;
const long interval = 30000; 
bool doorOpen = false;

//FUNÇÕES DE INICIALIZAÇÃO
void initDisplay();
void initWiFi();
void handleButtonPress();
void checkDoorTimeout();
void sendSensorData();
void openDoor();
void closeDoor();
void reconnectWiFiIfNeeded();

void setup() {
  Serial.begin(9600);
  pinMode(DOOR, OUTPUT);
  pinMode(DOOR_CLOSE, OUTPUT);
  pinMode(BOTON, INPUT);
  digitalWrite(DOOR, HIGH);
  pinMode(BUZZER_PIN, OUTPUT);

  dht.begin();
  initDisplay();
  initWiFi();
}

void loop() {
  handleButtonPress();
  checkDoorTimeout();
  sendSensorData();
  reconnectWiFiIfNeeded();
}

//INICIALIZAÇÃO DO OLED
void initDisplay() {
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println("Falha ao inicializar a tela OLED");
    while (1);
  }
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.drawBitmap(0, 0, adsLogo, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE);
  display.display();
  delay(150);
}

//CONECTAR WIFI
void initWiFi() {
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Conectando ao WiFi...");
  }
  Serial.println("WiFi conectado!");
}


void singleBeep(){
  digitalWrite(BUZZER_PIN, HIGH);
  delay(100);
  digitalWrite(BUZZER_PIN, LOW);
}


void dualBeep(){
  singleBeep();
  delay(100);
  singleBeep();
}


void handleButtonPress() {
  if (digitalRead(BOTON) == HIGH && !doorOpen) {
    openDoor();
    printData();
    singleBeep();
  }
}


void checkDoorTimeout() {
  if (doorOpen && millis() - doorOpenTime >= 5000) {
    closeDoor();
    printData();
    dualBeep();
  }
}

bool getDoorStatus(){
  if(digitalRead(DOOR) == HIGH){
    return false;
  }
  return true;
}

void displayData(float temperature, float humidity, float tmpOrv){
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextSize(1);
  display.print("Temp: ");
  display.print(temperature);
  display.println(" C");
  display.print("Umi: ");
  display.print(humidity);
  display.println(" %");
  display.print("Temp_Orv:");
  display.print(tmpOrv);
  display.println(" C");
  display.println();
  display.setTextSize(2);
  if(getDoorStatus()){
    display.println("ABERTA");
  }else{
    display.println("FECHADA");
  }
  display.display();
}

void printData(){
  float temperature = dht.readTemperature();
  float humidity = dht.readHumidity();
  float tmpOrv = (237.7 * (((17.27 * temperature) / (237.7 + temperature)) + 
                  log(humidity / 100))) / (17.27 - (((17.27 * temperature) / 
                  (237.7 + temperature)) + log(humidity / 100)));

  if (isnan(temperature) || isnan(humidity)) {
    Serial.println("Falha ao ler do sensor DHT!");
    return;
  }
  displayData(temperature, humidity, tmpOrv);
}

void sendSensorData() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    float temperature = dht.readTemperature();
    float humidity = dht.readHumidity();
    float tmpOrv = (237.7 * (((17.27 * temperature) / (237.7 + temperature)) + 
                  log(humidity / 100))) / (17.27 - (((17.27 * temperature) / 
                  (237.7 + temperature)) + log(humidity / 100)));

    if (isnan(temperature) || isnan(humidity)) {
      Serial.println("Falha ao ler do sensor DHT!");
      return;
    }

    displayData(temperature, humidity, tmpOrv);

    if (WiFi.status() == WL_CONNECTED) {
      HTTPClient http;
      http.begin(serverUrl);
      http.addHeader("Content-Type", "application/json");

      String jsonData = "{\"temperature\": " + String(temperature) + ", \"humidity\": " + String(humidity) + "}";
      int httpResponseCode = http.POST(jsonData);

      Serial.println(jsonData);
      if (httpResponseCode > 0) {
        String response = http.getString();
        Serial.println("Resposta do servidor: " + response);
      } else {
        Serial.println("Erro na requisição POST: " + String(httpResponseCode));
      }
      http.end();
    } else {
      Serial.println("Erro de conexão WiFi");
    }
  }
}

void openDoor() {
  Serial.println("Porta aberta");
  digitalWrite(DOOR, LOW);
  digitalWrite(DOOR_CLOSE, HIGH);
  doorOpen = true;
  doorOpenTime = millis();
}

void closeDoor() {
  Serial.println("Porta fechada");
  digitalWrite(DOOR, HIGH);
  digitalWrite(DOOR_CLOSE, LOW);
  doorOpen = false;
}

void reconnectWiFiIfNeeded() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Desconectado do WiFi, tentando reconectar...");
    WiFi.disconnect();
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
      delay(1000);
      Serial.println("Tentando reconectar ao WiFi...");
    }
    Serial.println("WiFi reconectado!");
  }
}